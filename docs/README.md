# EduRoll - Ethereum L2 ZK-Rollup Project

This project implements a full ZK-Rollup for tuition payments, designed as a set of decoupled, containerised services. The architecture separates L1 (Ethereum) consensus from L2 (EduRoll) computation.

## System Architecture & Operational Flow

[Click to view full size System Overview Diagram](./assets/diagrams/SystemOverview.png)

<a href="./assets/diagrams/SystemOverview.png">
  <img src="./assets/diagrams/SystemOverview.png" alt="System Overview Diagram" width="450"/>
</a>

The system's core design principle is **resilience and scalability**, achieved by using a central **Persistent Database (PostgreSQL)** as the single source of truth and communication hub for all off-chain services.

### Core Components

* **L1 Smart Contracts (Solidity):**
	* **`Rollup.sol`**: The primary L1 contract. It acts as the on-chain "ledger," storing the L2 state root.
	* **`Verifier.sol`**: A highly efficient contract (auto-generated by `snarkjs`) whose sole purpose is to mathematically verify ZK-SNARK proofs.
	* **`Bridge.sol`** — Handles deposits and withdrawals between L1 and L2.

	#### Helper Contracts & Tooling
* **`src/interfaces/ (Standardisation):`** Contains interface definitions (IBridge.sol, IRollup.sol, IVerifier.sol) for each core contract.

	- **Purpose:** These define the strict "contract-to-contract" rulebook. For example, IBridge ensures the Rollup contract knows exactly how to command the Bridge to release funds, decoupling the implementation from the definition.

* **`script/ (Deployment & Interaction):`** These are executable scripts used to deploy contracts and simulate real-world usage on local (Anvil) or public (Sepolia) testnets.

	- **Deploy.s.sol:** The master orchestrator. It deploys the Verifier, BridgeERC20, and Rollup contracts in the correct order and links them together (resolving circular dependencies).

	- **Deposit.s.sol:** Simulates a User action. It handles the ERC20 approve step and calls deposit() on the bridge.

	- **SubmitBatch.s.sol:** Simulates the Off-Chain Submitter. It constructs a transaction with a ZK-proof and new state root to update the Rollup contract.

	- **Withdraw.s.sol:** Simulates a User exit. It submits a Merkle proof to the Rollup contract to verify ownership before triggering a fund release.

* **`test/ (Security & Validation):`** These are unit tests written in Solidity to ensure the system is secure before deployment.

	- **Bridge.t.sol:** Validates that the bridge correctly locks tokens and, crucially, that only the Rollup contract is allowed to release them (access control).

	- **Rollup.t.sol:** Validates the state transition logic. It ensures that valid proofs update the state root, invalid proofs cause a revert, and withdrawals are only processed with a valid Merkle proof.

* **L2 Off-Chain Services (Rust & Docker):**
	* **`Test Client Container`**: A simulation utility that generates signed L2 transactions (tuition payments) and sends them to the Sequencer.
	* **`Sequencer Container`**: The "gatekeeper" of the L2 network. It receives transactions, validates them, and groups them into ordered batches.
	* **`Prover Container`**: The cryptographic "engine." It generates the ZK-SNARK proof that validates the state transition of a batch.
	* **`Archiver Container`**: A read-only "historian" service that indexes data from the database for external queries (e.g., a block explorer).
	* **`Submitter Container`**: The "finaliser." This service is responsible for sending the proven L2 batches and their proofs to the L1 `Rollup.sol` contract.
	* **`PersistentDB Container`**: A PostgreSQL database running in its own dedicated Docker container, with its data stored on a persistent Docker volume.
	It acts as the **single source of truth** and the central **communication hub** for all L2 services. Instead of communicating with each other directly (which is brittle), services operate asynchronously by reading and writing to the database.
	  * **Operational Flow:**
		  1.  The `Sequencer` writes a new batch with a status of `pending_proof`.
		  2.  The `Prover` polls the PersistentDB, finds this `pending_proof` batch, generates a proof, and updates the batch's status to `proven`.
		  3.  The `Submitter` polls the PersistentDB, finds this `proven` batch, and knows it's time to submit it to L1.

	  * **Why such design approach:** This decoupled architecture provides high **resilience** and **fault tolerance**. If the `Prover` crashes, the batch simply remains `pending_proof` in the database, and the service can safely resume its work upon restarting.

### System Setup Process

#### Phase 0: Merkle Tree — Keccak-256 vs Poseidon

Before starting the system implementation, a critical architectural decision must be made regarding the Merkle Tree, which acts as the `source of truth` for the system state.

1. **Ethereum (EVM) Context:** The Ethereum Virtual Machine natively uses the Keccak-256 hash function to generate Merkle Patricia Tries. Keccak-256 is a `bit-oriented` hash function (SHA-3 family) that relies heavily on bitwise operations such as XOR, AND, Rotations. [See Ethereum yellow paper](https://ethereum.github.io/yellowpaper/paper.pdf)
2. **The ZK Bottleneck:** Generating a single Keccak-256 hash in a ZK circuit is computationally expensive because bitwise operations must be decomposed into individual arithmetic constraints. A standard Keccak-256 implementation in Circom requires a significantly large number of constraints per hash. This makes frequent state updates within a rollup batch costly for the `Prover`. [See ZK-Circuits Benchmark in Circom paper](https://eprint.iacr.org/2023/681)

3. **ZK-Friendly Alternative:** Many ZK-Rollup solutions adopt a hybrid approach. They use Poseidon, a sponge-based hash function designed specifically for prime fields.

	3.1 **Arithmetic Efficiency:** Poseidon operates directly on field elements through $x^n$ S-boxes and MDS matrix multiplications. This results in only $210$–$300$ constraints per hash—a $500\times$ improvement over Keccak-256. [See ZK-Circuits Benchmark in Circom paper](https://eprint.iacr.org/2023/681)
	
	3.2 **EduRoll System :** EduRoll adopts a hybrid model. It utilises `Poseidon Sparse Merkle Trees (SMT)`. Sparse trees allow for the representation of a large address space efficiently by only storing non-zero leaves. Therefore, they significantly reduce the proof size for state inclusion.
	
	To decouple L1 and L2 without sacrificing L2 performance, the EduRoll system employs two distinct hashes:

	3.3.1. **L2 State Hash (Poseidon):** Used for internal state root transitions and ZK-proof generation.

	3.3.2. **L1 Interface Hash (Keccak):** Used by the `Submitter` to commit the L2 batch to the Ethereum L1 contract, ensuring compatibility with Ethereum.


#### Phase 1: ZK-Artifact Generation (Compile-Time)

Before the system can run, the ZK-SNARK components are generated from the circuit logic (as shown by the **purple Circuit** arrows):

1.  **Circuit Compilation:** The circuit logic (initially implemented in Circom, with Noir support planned for subsequent phases), is compiled into its mathematical representation the **`transfer.r1cs`** (Rank-1 Constraint System).

2.  **Key Generation:** This single `transfer.r1cs` file is used to generate two mathematically-linked components:
	* **L2 Proving Key (`transfer_final.zkey`):** A large (e.g., 100MB) file generated via a trusted setup. In the EduRoll project, **`Groth16`** is used, although other systems such as PLONK, PLONKish (UltraPLONK), Marlin, or Halo2 can also be used. **Groth16 was chosen because** it provides fast verification and a small Layer-1 **verifier contract**. This proving key is loaded by the **`Prover`** service to *generate* proofs.

	  * Below is a table for comparison of available libraries:

| System | Core Features | Trusted Setup | Verifier Cost | Used By |
| :--- | :--- | :--- | :--- | :--- |
| [**Groth16**](https://alinush.github.io/groth16) | Very fast verification; smallest proofs | Circuit-specific | **Lowest** | Filecoin, many Circom projects |
| [**PLONK**](https://eprint.iacr.org/2019/953.pdf) | Universal setup; flexible | Universal | Medium | Aztec 1, early zkSync |
| [**UltraPLONK / TurboPLONK**](https://hackmd.io/@aztec-network/plonk-arithmetiization-air) | Lookup/optimized gates; scalable | Universal | Medium | Polygon zkEVM (variants) |
| [**Marlin**](https://eprint.iacr.org/2019/1047.pdf) | Transparent; succinct | Transparent | Medium | Mina ecosystem |
| [**Halo2**](https://eprint.iacr.org/2019/1021.pdf) | Recursion-friendly; flexible; modern | Transparent | Higher | Zcash, Scroll (with KZG) |
| [**STARKs**](https://eprint.iacr.org/2018/046.pdf) | Fast proving; highly scalable; hash-based | Transparent | High (large proofs) | StarkNet |
| **[Spartan](https://github.com/microsoft/Spartan2) / [HyperPlonk](https://eprint.iacr.org/2022/1355.pdf)** | Modular, research-focused systems | Mixed | Varies | Research prototypes |


The EduRoll project currently utilizes a local trusted setup for the Groth16 proving system. In a production environment, this requires a `Multi-Party Computation (MPC) ceremony` (often referred to as a `Powers of Tau` ceremony) to generate the Common Reference String (CRS). This ceremony ensures that the `toxic waste`(randomness used during setup) is deleted. Additionally, the security of the system relies on the assumption that at least one participant in the MPC was honest and destroyed their contribution. [See this paper] for a detailed explanation (https://eprint.iacr.org/2017/1050.pdf) and [this repo.](https://github.com/iden3/snarkjs)


* **L1 Verifier (`Verifier.sol`):** A small (e.g., 5KB) Solidity contract generated by `snarkjs`. It is deployed to L1 to *check* proofs.

#### Phase 2: Runtime Operational Flow (End-to-End)

This describes how transactions are processed on the rollup in batches and then submitted to Layer-1 Ethereum.
- A batch is accepted to consist of 100 transactions in this project.
- This is for the local deployment as we do not want to have memory exhaustion during the witness generation process.
- However, a larger number (e.g. 1,000 transactions) is favoured in industry applications to gas amortisation.

1.  **Step 1: Ingestion (Data Flow)**
	* The `TEST CLIENT` generates and sends signed L2 transactions to the `SEQUENCER`'s RPC endpoint.

2.  **Step 2: Batching (Data Flow)**
	* The `SEQUENCER` validates the transactions and stores it in the `txs` table of the `PERSISTENTDB`.
	* Periodically, the `SEQUENCER` fetches a list of pending transactions, reads the current state from the `accounts` table, and executes them (using the `execution` and `merkle` crates) to calculate a new **state root**.
	* It writes this new batch (new state root, list of tx hashes, etc.) to the `batches` table, marking it as `pending_proof`.

3.  **Step 3: Proving (Proof Flow)**
	* The `PROVER` is continuously polling the `PersistentDB`. It finds a `pending_proof` batch.
	* It reads the batch data, loads its `transfer_final.zkey`, and generates the ZK-SNARK proof (`a, b, c`) that validates the state transition. Read this for ZK-SNARK proof generation. See [this paper](https://eprint.iacr.org/2016/260.pdf) for how the proof are generated and [this repo](https://github.com/iden3/snarkjs) for interacting.

	* The `PROVER` writes this proof back to the `batches` table in the `PersistentDB` and updates the status to `proven`.

4.  **Step 4: Archiving (Data Flow)**
	* In parallel, the `ARCHIVER` is constantly reading the `PersistentDB` (both `txs` and `batches` tables) and indexing them for historical queries. This service does not write or alter the rollup's state.

5.  **Step 5: Submission & Verification (Proof Flow)**
	* The `SUBMITTER` polls the `PersistentDB` and finds a `proven` batch.
	* It reads the proof (`a, b, c`) and the public inputs (the old and new state roots).
	* It submits an L1 transaction to the **`Rollup.sol`** contract, calling the `submitBatch()` function with the proof and public inputs.
	* `Rollup.sol` receives the call and immediately passes the proof data to the **`Verifier.sol`** contract by calling `verifyProof()`.
	* `Verifier.sol` runs the on-chain cryptographic check. If the proof is valid, it returns `true`.
	* `Rollup.sol` receives `true`, requires the check to pass, and updates its internal `stateRoot` variable to the new state root from the batch.

At this point, the L2 batch is officially finalized and secured by L1 consensus.